require('dotenv').config();
const express = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const bcrypt = require('bcryptjs');
const cookieParser = require('cookie-parser');
const { body, validationResult } = require('express-validator');

const app = express();
app.use(express.json());
app.use(cookieParser());
app.use(helmet());

const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 200 });
app.use(limiter);

const PORT = process.env.PORT || 4000;
const JWT_SECRET = process.env.JWT_SECRET || 'replace_this_access_secret';
const REFRESH_SECRET = process.env.REFRESH_SECRET || 'replace_this_refresh_secret';
const ACCESS_EXP = process.env.ACCESS_EXP || '15m';
const REFRESH_EXP_MS = parseInt(process.env.REFRESH_EXP_MS || String(7 * 24 * 60 * 60 * 1000), 10);

const users = [];
const refreshStore = new Map();

async function seedUsers() {
  const adminPass = await bcrypt.hash('AdminPass123!', 10);
  const userPass = await bcrypt.hash('UserPass123!', 10);
  users.push({ id: 'u1', username: 'alice', passwordHash: userPass, role: 'customer' });
  users.push({ id: 'u2', username: 'bob', passwordHash: adminPass, role: 'admin' });
}

function signAccessToken(user) {
  return jwt.sign({ sub: user.id, username: user.username, role: user.role }, JWT_SECRET, { expiresIn: ACCESS_EXP });
}

function signRefreshToken(user) {
  const token = jwt.sign({ sub: user.id }, REFRESH_SECRET, { expiresIn: '7d' });
  const hashed = crypto.createHash('sha256').update(token).digest('hex');
  const expiresAt = Date.now() + REFRESH_EXP_MS;
  refreshStore.set(hashed, { userId: user.id, expiresAt });
  return token;
}

function revokeRefreshToken(token) {
  const hashed = crypto.createHash('sha256').update(token).digest('hex');
  return refreshStore.delete(hashed);
}

function validateRefreshToken(token) {
  try {
    const payload = jwt.verify(token, REFRESH_SECRET);
    const hashed = crypto.createHash('sha256').update(token).digest('hex');
    const record = refreshStore.get(hashed);
    if (!record) return null;
    if (record.expiresAt < Date.now()) { refreshStore.delete(hashed); return null; }
    return record.userId;
  } catch (e) {
    return null;
  }
}

function authenticateJWT(req, res, next) {
  const auth = req.headers['authorization'] || '';
  if (!auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Unauthorized' });
  const token = auth.slice(7).trim();
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = { id: payload.sub, username: payload.username, role: payload.role };
    return next();
  } catch (e) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

function authorizeRoles(...roles) {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ error: 'Unauthorized' });
    if (!roles.includes(req.user.role)) return res.status(403).json({ error: 'Forbidden' });
    next();
  };
}

app.post('/auth/login',
  body('username').isString().trim().notEmpty(),
  body('password').isString().notEmpty(),
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });
    const { username, password } = req.body;
    const user = users.find(u => u.username === username);
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
    const accessToken = signAccessToken(user);
    const refreshToken = signRefreshToken(user);
    res.cookie('refreshToken', refreshToken, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: REFRESH_EXP_MS });
    res.json({ accessToken, expiresIn: ACCESS_EXP });
  }
);

app.post('/auth/refresh', (req, res) => {
  const token = req.cookies.refreshToken || req.body.refreshToken;
  if (!token) return res.status(401).json({ error: 'No refresh token' });
  const userId = validateRefreshToken(token);
  if (!userId) return res.status(401).json({ error: 'Invalid refresh token' });
  const user = users.find(u => u.id === userId);
  if (!user) return res.status(401).json({ error: 'User not found' });
  revokeRefreshToken(token);
  const newAccess = signAccessToken(user);
  const newRefresh = signRefreshToken(user);
  res.cookie('refreshToken', newRefresh, { httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: REFRESH_EXP_MS });
  res.json({ accessToken: newAccess, expiresIn: ACCESS_EXP });
});

app.post('/auth/logout', (req, res) => {
  const token = req.cookies.refreshToken || req.body.refreshToken;
  if (token) revokeRefreshToken(token);
  res.clearCookie('refreshToken');
  res.json({ ok: true });
});

app.get('/accounts', authenticateJWT, authorizeRoles('customer', 'admin'), (req, res) => {
  res.json({ accounts: [{ id: 'acc1', owner: req.user.username, balance: 12345.67 }] });
});

app.get('/admin/accounts', authenticateJWT, authorizeRoles('admin'), (req, res) => {
  res.json({ accounts: [{ id: 'acc1', owner: 'alice', balance: 12345.67 }, { id: 'acc2', owner: 'charlie', balance: 98765.43 }] });
});

app.post('/transactions',
  authenticateJWT,
  authorizeRoles('customer'),
  body('toAccount').isString().notEmpty(),
  body('amount').isFloat({ gt: 0 }),
  (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });
    const { toAccount, amount } = req.body;
    res.json({ txId: crypto.randomUUID(), from: req.user.username, to: toAccount, amount });
  }
);

app.use((err, req, res, next) => {
  console.error(err && err.stack ? err.stack : err);
  res.status(500).json({ error: 'Internal Server Error' });
});

seedUsers().then(() => {
  app.listen(PORT, () => {
    console.log(`Secure Banking API running on port ${PORT}`);
  });
});
